" Include Arista-specific settings
if filereadable( $VIM . "/vimfiles/arista.vim" )
   let a4_auto_edit=0
   source $VIM/vimfiles/arista.vim
endif

" Plugins via Vundle
call plug#begin()
Plug 'VundleVim/Vundle.vim'
Plug 'mileszs/ack.vim'
Plug 'gregsexton/gitv'
Plug 'tmhedberg/matchit'
Plug 'vim-scripts/python_match.vim'
Plug 'majutsushi/tagbar'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'haya14busa/vim-asterisk'
Plug 'flazz/vim-colorschemes'
Plug 'kana/vim-fakeclip'
Plug 'tpope/vim-fugitive'
Plug 'mhinz/vim-hugefile'
Plug 'tpope/vim-jdaddy'
Plug 'tpope/vim-surround'
Plug 'tex/vim-unite-id'
Plug 'vim-scripts/DirDiff.vim'
Plug 'tmux-plugins/vim-tmux-focus-events'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'd11wtq/ctrlp_bdelete.vim'
call plug#end()

" Options for editing
set nocompatible
filetype plugin indent on
set shiftwidth=3
set tabstop=3
set linebreak
set textwidth=85
set cindent
set autoindent
set smarttab
set expandtab
set nospell
set virtualedit=all
set complete-=i

" Mouse support with tmux
set mouse=a
if &term =~ '^screen'
   " tmux knows the extended mouse mode
   set ttymouse=xterm2
endif

" Don't save options in sessions
set sessionoptions-=options
set sessionoptions-=folds

" Make splits appear as expected
set splitbelow
set splitright

" Prevent key pauses
set timeout
set ttimeout
set timeoutlen=1000
set ttimeoutlen=0

" Options for setting the bottom 2 lines
set showmode
set laststatus=2
set ruler

" Show non-printing characters
set list
set listchars=tab:»\ ,trail:·

" UI stuff
set background=light
function! SetColours()
   try
      colorscheme solarized
   catch /^Vim\%((\a\+)\)\=:E185/
      colorscheme desert
   endtry
endfunction
call SetColours()

syntax enable
set nocursorline
set visualbell
set ignorecase
set smartcase
set guioptions=aeir
set hidden
set hlsearch
set incsearch
set showcmd
set wildmenu
set lazyredraw
set autoread

" Highlight cursor line only in current window
augroup CulHighlight
   autocmd!
   autocmd WinEnter * set cul
   autocmd WinLeave * set nocul
augroup END

if has("gui_running")
  if has("gui_win32")
    set guifont=Lucida_Console:h10:cDEFAULT
  endif
endif

" Options for folding
set foldmethod=indent           "fdm:   fold by the indentation by default
set nofoldenable                "nofen: don't fold by default

" Options for backup files
set nobackup
set nowritebackup
if has('unix')
   set directory=/tmp
else
   set directory=$TEMP
endif

" define a group `vimrc` and initialize.
augroup vimrc
   autocmd!
augroup END

" Options for vimdiff
set diffopt=filler,vertical
" Automatically diffupdate on write
autocmd vimrc BufWritePost * if &diff == 1 | diffupdate | endif

" Always move some windows to the bottom
autocmd vimrc FileType qf wincmd J
autocmd vimrc FileType gitcommit wincmd J

" Treat *.md files as markdown instead of Modula-2
autocmd vimrc BufNewFile,BufReadPost *.md set filetype=markdown
autocmd vimrc BufNewFile,BufReadPost *.md set textwidth=0

" Treat *.*tin files as C++
autocmd vimrc BufNewFile,BufReadPost *.*tin set filetype=cpp

" Mappings
let g:mapleader = "\<Space>"
map Y y$
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
nnoremap <Leader>tc :tabclose<return>
nnoremap <Leader>tn :tabnew<return>
nnoremap <Leader>te :tabedit<space>
nnoremap <Leader>tm :tabmove<space>
nnoremap j gj
nnoremap k gk
cmap w!! %!sudo tee > /dev/null %
noremap <silent><Leader>/ :nohls<CR>
nnoremap <Leader>ms :mksession! ~/.vim_session<CR> " Quick write session
nnoremap <Leader>ls :source ~/.vim_session<CR>     " And load session
nnoremap <Leader>\| :vsp<cr>
nnoremap <Leader>- :sp<cr>
nnoremap <Leader>= <C-w>=
nnoremap <Leader>o :only<cr>
nnoremap <Leader>c :close<cr>
nnoremap <Leader>p :set paste!<cr>
nnoremap <Leader>C :call SetColours()<cr> " Fix colors when they get messed

" Highlight long lines (based on textwidth)
nnoremap <silent> <Leader>L
      \ :if exists('w:long_line_match') <Bar>
      \   silent! call matchdelete(w:long_line_match) <Bar>
      \   unlet w:long_line_match <Bar>
      \ elseif &textwidth > 0 <Bar>
      \   let w:long_line_match = matchadd('ErrorMsg', '\%>'.&tw.'v.\+', -1) <Bar>
      \ else <Bar>
      \   let w:long_line_match = matchadd('ErrorMsg', '\%>80v.\+', -1) <Bar>
      \ endif<CR>

" Search for 'tags' file starting in the current dir and then moving up
set tags=tags;/

" Grepping
set errorfile=/home/jhornsbe/errors.txt
set path=**

if system("ag -h") || !v:shell_error
   set grepprg=ag\ --all-text\ --nogroup\ --nocolor\ --column\ --silent\ --smart-case\ --path-to-agignore\ ~/.agignore\ --skip-vcs-ignores
elseif executable("ack")
   set grepprg=ack\ --no-group\ -k\ --flush
elseif executable("ack-grep")
   set grepprg=ack-grep\ --no-group\ --flush
else
   set grepprg=internal
endif

" Allow netrw to delete non-empty directories
let g:netrw_localrmdir='rm -r'

" Airline plugin
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_buffers = 0
let g:airline#extensions#tabline#tab_min_count = 2

" Tagbar plugin
map <Leader>l :TagbarToggle<CR>
let g:tagbar_compact = 1
let g:tagbar_autofocus = 1
let g:tagbar_sort = 0
let g:tagbar_left = 1
let g:tagbar_type_tac = {
   \ 'ctagstype' : 'tacc',
   \ 'kinds'     : [
       \ 'd:definition'
   \ ],
   \ 'sort'    : 0
\ }

" vim-asterisk plugin
map <silent> *  <Plug>(asterisk-z*)
map <silent> #  <Plug>(asterisk-z#)
map <silent> g* <Plug>(asterisk-gz*)
map <silent> g# <Plug>(asterisk-gz#)

" Gitv plugin
let g:Gitv_DoNotMapCtrlKey = 1

" Fugitive plugin
map <Leader>g :Ggrep 

" Ack plugin
let g:ackprg = &grepprg
map <Leader>a :Ack! 

" Hugefile plugin
let g:hugefile_trigger_size = 50

" DirDiff plugin
" ignore white space in diff
let g:DirDiffAddArgs = "-w"

" CtrlP plugin
let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix']
if system("ag -h") || !v:shell_error
   let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
endif
let g:ctrlp_map = '<Leader>p'
map <silent> <Leader>f :CtrlP<cr>
map <silent> <Leader>r :CtrlPMRU<cr>
map <silent> <Leader>b :CtrlPBuffer<cr>
map <silent> <Leader>t :CtrlPBufTag<cr>
map <silent> <Leader>T :CtrlPTag<cr>
map <silent> <Leader>q :CtrlPQuickfix<cr>
call ctrlp_bdelete#init()
